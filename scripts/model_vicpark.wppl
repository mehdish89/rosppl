var toQuaternion = function(e) {


	var phi = e.z != undefined ? e.z : 0.; 
	var theta = e.x != undefined ? e.x : 0.; 
	var psi = e.y != undefined ? e.y : 0.; 

    var _x = theta * 0.5;
    var _y = psi * 0.5;
    var _z = phi * 0.5;

    var cX = Math.cos(_x);
    var cY = Math.cos(_y);
    var cZ = Math.cos(_z);

    var sX = Math.sin(_x);
    var sY = Math.sin(_y);
    var sZ = Math.sin(_z);

    var q =  {
      w: cX * cY * cZ - sX * sY * sZ,
      x: sX * cY * cZ - cX * sY * sZ,
      y: cX * sY * cZ + sX * cY * sZ,
      z: cX * cY * sZ + sX * sY * cZ
    }   

    return q
}


var secs = function(stamp){
	return stamp.secs + stamp.nsecs * Math.pow(10, -9)
}

// var L = 2.83
// var H = 0.76
// var b = 0.5
// var a = 3.78

var EPS = 0.1


var sig_s = 5 * Math.PI / 180
var sig_v = 0.1

var vicpark_transition = function(state, dr, params){
	var L = params.L
	var H = params.H
	var b = params.b
	var a = params.a

	var s = dr.drive.steering_angle + gaussian(0, params.sig_s)
	var v = dr.drive.speed / (1 - Math.tan(s) * H / L) + gaussian(0, params.sig_v)


	var dt = state.ts ? secs(dr.header.stamp) - secs(state.ts) : 0.

	var sth = Math.sin(state.theta)
	var cth = Math.cos(state.theta)
	var tanth = Math.tan(state.theta)
	var tans = Math.tan(s)

	var x = state.x + dt * (v * cth - v * tans * (a * sth + b * cth) / L)
	var y = state.y + dt * (v * sth + v * tans * (a * cth - b * sth) / L)

	// var x = state.x + dt * (v * cth)
	// var y = state.y + dt * (v * sth)

	var th = (state.theta + dt * v * tans / L) % (2 * Math.PI)

	return {
		x: x,
		y: y,
		theta: th,
		ts: dr.header.stamp
	}
}

var distance = function(a, b){
	return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))
}


var to_landmark = function(pose, tree){
	var xv = pose.x + a * Math.cos(pose.theta) - b * Math.sin(pose.theta)
	var yv = pose.y + a * Math.sin(pose.theta) + b * Math.cos(pose.theta)

	return {
		x: xv + tree.distance * Math.sin(tree.angle + pose.theta),
		y: yv - tree.distance * Math.cos(tree.angle + pose.theta),
		d: tree.diameter
	}
}


var sig_r = 0.005
var sig_b = 2 * Math.PI / 180
var sig_d = 0.00000001

var vicpark_observer = function(pose, lm, params) {
	// var xv = pose.x + a * Math.cos(pose.theta) - b * Math.sin(pose.theta)
	// var yv = pose.y + a * Math.sin(pose.theta) + b * Math.cos(pose.theta)
	var sig_r = params.sig_r
	var sig_b = params.sig_b

	var xv = pose.x 
	var yv = pose.y

	var pv = {x: xv, y: yv}

	var mu_r = distance(pv, lm)
	var mu_b = (Math.atan2(pv.y-lm.y, pv.x-lm.x) - pose.theta + 1.5 * Math.PI) % (2 * Math.PI)



	var gauss_r = Gaussian({mu: mu_r, sigma: sig_r})
	var gauss_b = Gaussian({mu: mu_b, sigma: sig_b})
	// var gauss_d = Gaussian({mu: lm.d, sigma: sig_d})
 
	return function(tree){
		// console.log(mu_r + " -- " + tree.distance)
		// console.log(mu_b + " -- " + tree.angle + " | " + (mu_b - tree.angle))

		return gauss_r.score(tree.distance) +
			   gauss_b.score(tree.angle) 
			   // +
			   // gauss_d.score(tree.diameter)
	}
}


var SCORE_THR = -4.0
var INF_FUNC = function(x){return -Infinity}

var observe_trees = function(state, trees) {

	var observers = map(function(landmark){
		return vicpark_observer(state.pose, landmark)
	}, state.landmarks)

	var novels = filter(function(tree){

		var best = reduce(function(observer, acc){
		
			return observer(tree) > acc(tree) ? observer : acc

		}, INF_FUNC, observers)

		var best_score = best(tree)

		if(best_score > SCORE_THR){
			factor(best_score)
			return false
		}

		return true

	}, trees)

	return map(to_landmark, novels)
}

var myfactor = function(score){
	var sumW = globalStore._sumW
	var numFactorCalls = globalStore._numFactorCalls
	globalStore._sumW = (_sumW * numFactorCalls + score) / (numFactorCalls + 1)
    globalStore._numFactorCalls = numFactorCalls + 1

    factor(score)

    // console.log(globalStore._sumW)
}


var pose_expectation = function(dist){
	return {
		x: expectation(dist, function(p){p.pose.x}),
		y: expectation(dist, function(p){p.pose.y}),
		theta: expectation(dist, function(p){p.pose.theta}),
		ts: MAP(dist).val.pose.ts,
	}
}


var model = function(readings, records, prior, params){

	var last = prior!=undefined && typeof prior.support=="function" ? sample(prior) : prior
	// var last = prior!=undefined && typeof prior.support=="function" ? MAP(prior).val : prior

	condition(params.sig_s>0 && params.sig_v>0)

	// var current = readings.dr ? vicpark_transition(last.pose, readings.dr, params) : last.pose
	var current = records.dr ? vicpark_transition(last.pose, records.dr, params) : last.pose

	


	if(readings.trees && records.map)
		map(function(tree){

			var observer = vicpark_observer(current, records.map.landmarks[tree.id-1], params)
			var score = observer(tree)
			// console.log(score)
			// console.log("landmark "+tree.id)
			factor(score)
		}, readings.trees.trees)


	// var landmarks = readings.trees ? 
	// 					map(function(tree){
	// 						return to_landmark(current, tree)
	// 					}, readings.trees.trees) : last.landmarks

	// var fake = {pose: current, landmarks: landmarks}	

	// var new_landmarks = readings.trees ? observe_trees(fake, readings.trees.trees) : []

	// console.log(new_landmarks)


	return { 
		pose: current,
		readings: readings, 
		// landmarks: new_landmarks 
	}
}

var policy = function(posterior){
	var last = MAP(posterior).val
	var pose = pose_expectation(posterior)
	var ts = pose.ts ? pose.ts : {secs: 0, nsecs: 0}
	var ps = {
		header: {
			stamp: ts,
			frame_id: 'world'
		},

		pose: {
			position: {
				x: pose.x,
				y: pose.y
			},
			orientation: toQuaternion({z: pose.theta})
		}
	}

	var odom = {
		header: {
			stamp: ts,
			frame_id: 'world'
		},
		child_frame_id: 'odom',
		pose:{
			pose: ps.pose
		}
	}


	return {
		pose: ps,
		odom: odom,
		landmarks: {
			landmarks: last.landmarks
		}
	}
}


globalStore.model = model
globalStore.policy = policy
globalStore.prior = {
	pose: {
		x: -67.6492,
		y: -41.7142,
		theta: 3.3 * Math.PI / 16,
	}
}

globalStore.subs = {
	// twist: "/robot0/cmd_vel",
	// ranges: "/robot0/laser_0/ranges",
	// gth: "/robot0/odom/pose/pose",
	// dr: "/dead_reckoning",
	trees: "/trees",
}

globalStore.pubs = {
	pose: "/pose",
	odom: "/odom",
	// landmarks: "/landmarks",
}

globalStore.reps = {
	map: "/map",
	dr: "/dead_reckoning",
}

globalStore.params = {
	// sig_s: Gaussian({mu: 1, sigma: 1}),//*/ 0.016, // 5 * Math.PI / 180,
	// sig_v: Gaussian({mu: 1, sigma: 1}),//*/ 0.16   // 0.1,

	sig_s: /*Gamma({shape: 1, scale: 1}),//*/ 0.016, // 5 * Math.PI / 180,
	sig_v: /*Gamma({shape: 1, scale: 1}),//*/ 0.16,   // 0.1,
	sig_r: /*Gamma({shape: 1, scale: 1}), //*/  0.28, //0.12, //0.005,
	sig_b: /*Gamma({shape: 1, scale: 1}), //*/  0.012, //2 * Math.PI / 180,

	L: /*Gamma({shape: 1, scale: 1}),//*/ 2.83, // 5 * Math.PI / 180,
	H: /*Gamma({shape: 1, scale: 1}), //*/  0.76,
	b: /*Gamma({shape: 1, scale: 1}), //*/  0.5,
	a: /*Gamma({shape: 1, scale: 1}), //*/  3.78,

	true_sig_s: /*Gamma({shape: 1, scale: 1}),//*/ 0.016, // 5 * Math.PI / 180,
	true_sig_v: /*Gamma({shape: 1, scale: 1}),//*/ 0.2,   // 0.1,
	true_sig_r: /*Gamma({shape: 1, scale: 1}), //*/  0.28, //0.005,
	true_sig_b: /*Gamma({shape: 1, scale: 1}), //*/  0.012, //2 * Math.PI / 180,

	true_L: /*Gamma({shape: 1, scale: 1}),//*/ 2.83, // 5 * Math.PI / 180,
	true_H: /*Gamma({shape: 1, scale: 1}), //*/  0.76,
	true_b: /*Gamma({shape: 1, scale: 1}), //*/  0.5,
	true_a: /*Gamma({shape: 1, scale: 1}), //*/  3.78,
}

// globalStore.options = {
// 	param_infer: true,
// }

